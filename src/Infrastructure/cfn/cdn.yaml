AWSTemplateFormatVersion: 2010-09-09
Description: Storage infrastructure for the Bits & Bobs application

Parameters:
  Environment:
    Type: String
    Default: Development
    Description: The environment for which the resources are being created
    AllowedValues:
      - Development
      - Staging
      - Production

  AppBucketDomainName:
    Type: String
    Description: The domain name of the S3 bucket for the client app

  LoggingBucketDomainName:
    Type: String
    Description: The domain name of the S3 bucket for logs

  EksClusterArn:
    Type: String
    Description: The ARN of the EKS cluster (this is really only here as a flag and to create a stack dependency)

  EksLoadBalancerArn:
    Type: String
    Default: ''
    Description: The ARN of the load balancer created by EKS

  EksLoadBalancerDomainName:
    Type: String
    Default: ''
    Description: The domain name of the load balancer created by EKS

Conditions:
  EksClusterExistsCondition: !Not [ !Equals [ !Ref EksClusterArn, "" ] ]
  CreateEksVpcOriginCondition: !And
    - !Condition EksClusterExistsCondition
    - !Not [ !Equals [ !Ref EksLoadBalancerArn, ""] ]
    - !Not [ !Equals [ !Ref EksLoadBalancerDomainName, "" ] ]

Resources:
  # The CloudFront distribution exposing both the client app and api
  CFDistribution:
    # checkov:skip=CKV_AWS_68:This is a demo, we don't need to pay for WAF
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Origins:
          - DomainName: !Ref AppBucketDomainName
            Id: S3Origin
            S3OriginConfig:
              OriginAccessIdentity: ""
            OriginAccessControlId: !GetAtt CloudFrontOriginAccessControl.Id
          - !If
            - CreateEksVpcOriginCondition
            - DomainName: !Ref EksLoadBalancerDomainName
              Id: EksOrigin
              VpcOriginConfig:
                VpcOriginId: !Ref EksVpcOrigin
            - !Ref AWS::NoValue
        Enabled: 'true'
        DefaultRootObject: index.html
        DefaultCacheBehavior:
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          TargetOriginId: S3Origin
          # https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-cache-policies.html#managed-cache-policy-caching-disabled
          CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # CachingDisabled
          # https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-origin-request-policies.html
          OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf # CORS-S3Origin
          # https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/using-managed-response-headers-policies.html
          #ResponseHeadersPolicyId: eaab4381-ed33-4a86-88ca-d9558dc6cd63 # CORS-with-preflight-and-SecurityHeadersPolicy
          ViewerProtocolPolicy: redirect-to-https
          Compress: true
          FunctionAssociations:
            - EventType: viewer-request
              FunctionARN: !GetAtt SpaPathFunction.FunctionARN
        CacheBehaviors:
          - !If
            - CreateEksVpcOriginCondition
            - PathPattern: /api/*
              AllowedMethods:
                - GET
                - HEAD
                - OPTIONS
                - PUT
                - PATCH
                - POST
                - DELETE
              TargetOriginId: EksOrigin
              CachePolicyId: 4135ea2d-6df8-44a3-9df3-4b5a84be39ad # CachingDisabled
              OriginRequestPolicyId: 216adef6-5c7f-47e4-b989-5492eafa07d3 # AllViewer
              ViewerProtocolPolicy: redirect-to-https
              Compress: true
            - !Ref AWS::NoValue
          - PathPattern: /images/*
            AllowedMethods:
              - GET
              - HEAD
              - OPTIONS
            TargetOriginId: S3Origin
            CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6 # CachingOptimized
            OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf # CORS-S3Origin
            ViewerProtocolPolicy: redirect-to-https
            FunctionAssociations:
              - EventType: viewer-request
                FunctionARN: !GetAtt SpaPathFunction.FunctionARN
          - PathPattern: /assets/*
            AllowedMethods:
              - GET
              - HEAD
              - OPTIONS
            TargetOriginId: S3Origin
            CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6 # CachingOptimized
            OriginRequestPolicyId: 88a5eaf4-2fd4-4709-b370-b4c650ea3fcf # CORS-S3Origin
            ViewerProtocolPolicy: redirect-to-https
            Compress: true
            FunctionAssociations:
              - EventType: viewer-request
                FunctionARN: !GetAtt SpaPathFunction.FunctionARN
        PriceClass: PriceClass_All
        Logging:
          Bucket: !Ref LoggingBucketDomainName
          Prefix: 'cf-access-logs'
        ViewerCertificate:
          CloudFrontDefaultCertificate: true
          MinimumProtocolVersion: 'TLSv1.2_2021'

  # This is flaky. When EKS swaps the LB out (e.g. because you make changed to ingress) then the LB ARN changes and the VPC
  # Origin will no longer work and will need to be recreated, but it can't easily be re-created because CloudFront depends on it.
  EksVpcOrigin:
    Type: AWS::CloudFront::VpcOrigin
    Condition: CreateEksVpcOriginCondition
    Properties:
      VpcOriginEndpointConfig:
        Name: !Sub EksLbVpcOrigin-${Environment}
        Arn: !Ref EksLoadBalancerArn
        HTTPPort: 80
        OriginProtocolPolicy: http-only

  # CloudFront origin access control
  CloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Description: Default Origin Access Control
        Name: !Sub 'OriginAccessControl-${Environment}'
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  CFKeyValueStore:
    Type: AWS::CloudFront::KeyValueStore
    Properties:
      Name: !Sub 'CFKeyValueStore-${Environment}'

  SpaPathFunction:
    Type: AWS::CloudFront::Function
    Properties:
      Name: !Sub 'SpaPathFunction-${Environment}'
      AutoPublish: true
      FunctionConfig:
        Comment: >
          Prefixes SPA paths with the version number stored in the CFN KVS. Also rewrites all SPA routes (i.e. not
          /assets or /images) to / so that they'll be handled by the SPA but won't generate 404 errors. Usually this
          would be handled with custom error responses, but we don't want to mask errors from the API (or missing
          assets or images).
        Runtime: cloudfront-js-2.0
        KeyValueStoreAssociations:
          - KeyValueStoreARN: !GetAtt CFKeyValueStore.Arn
      FunctionCode: |
        import cf from 'cloudfront';

        // This relies on the KVS being associated with the function
        const kvs = cf.kvs();

        async function handler(event) {
          const request = event.request;
          const originalUri = request.uri;
          const pathSegments = request.uri.split('/')
          if (!['assets', 'images'].includes(pathSegments[1])) {
            request.uri = '/index.html'
          }
          try {
            const hasVersion = await kvs.exists('current-version')
            if (hasVersion) {
              const version = await kvs.get('current-version', { format: 'string' });
              request.uri = '/' + version + request.uri;
            }
            console.log(`${originalUri} -> ${request.uri}`);
          } catch (error) {
            console.log(`${request.uri} | ${err}`);
          }
          return request;
        }

Outputs:
  DomainName:
    Value: !GetAtt CFDistribution.DomainName
  KeyValueStoreArn:
    Value: !GetAtt CFKeyValueStore.Arn
  KeyValueStoreId:
    Value: !GetAtt CFKeyValueStore.Id
